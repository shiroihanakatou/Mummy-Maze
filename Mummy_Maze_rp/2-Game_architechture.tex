\chapter{Thuật toán và cách triển khai trong game}
\label{chap:chapter2}

\section{Giới thiệu chung}
Mummy Maze được xây dựng bằng Python và Pygame theo kiểu \textbf{grid-based turn game}: player đi \textbf{1 hành động}, sau đó enemy đi lần lượt theo lượt.
Ngoài Pygame, game dùng \textbf{JSON} để lưu \textbf{level} (assets/map/) và \textbf{save file} (local profile), nhằm giúp nhóm mở rộng nội dung mà không phải sửa gameplay core.

\section{Tổ chức mã nguồn}

\subsection{Cấu trúc thư mục (theo file tree hiện tại)}
\begin{verbatim}
game/
  main.py
  saveload.py
  sprite_cutting.py
  variable.py
  assets/
    characters/  font/  images/  map/  music/  screen/  sounds/  sprite_sheet/
entity/
  entity.py
module/
  gamestate.py
  module.py
screen/
  button.py
  login.py
skin_module/
  skin_loader.py
  skin_screen.py
utils/
\end{verbatim}

\subsection{Vai trò từng nhóm file (bám sát naming trong code)}
\begin{itemize}
    \item \textbf{\texttt{game/main.py}}: \textbf{state machine} tổng (LOGIN / SELECTION / PLAYING / OPTIONS / CHARACTER\_SELECT / LOSE\_MENU...), vòng lặp chính, bắt input, gọi \texttt{player.move()}, chạy \textbf{turn system}, gọi \textbf{save/load}, điều phối UI và gameplay.
    \item \textbf{\texttt{game/variable.py}}: cấu hình runtime (CELL\_SIZE, FPS, ROWS/COLS theo grid, scale, màu...).
    \item \textbf{\texttt{entity/entity.py}}: định nghĩa \textbf{Cell, Player, Enemy}. Đây là nơi có logic di chuyển từng entity và hệ animation/slide (render\_dx/render\_dy, move\_timer/move\_total, is\_moving).
    \item \textbf{\texttt{module/module.py}}: \textbf{thuật toán lõi}:
    \begin{itemize}
        \item snapshot: \texttt{make\_snapshot()}, \texttt{apply\_snapshot()}
        \item generate: \texttt{generate\_game()}, \texttt{generate\_walls\_pr()} (Prim)
        \item BFS solvable + solution: \texttt{path\_finding()}, \texttt{is\_playable()}
        \item AI quái: \texttt{new\_enemy\_position()} (Manhattan), \texttt{impossible\_mode\_move()} (BFS)
        \item đọc map JSON: \texttt{read\_map\_json()}
        \item xử lý tile đặc biệt: \texttt{check\_special\_tiles()}, \texttt{toggle\_gates()}
    \end{itemize}
    \item \textbf{\texttt{module/gamestate.py}}: class \texttt{Gamestate} giữ \textbf{toàn bộ state gameplay dùng chung} (mode, level/chapter, keys/traps/gates\_h, storedmove/initpos, solution, gate\_anim\_state, cờ gameover, trạng thái death animation...).
    \item \textbf{\texttt{game/saveload.py}}: build cấu trúc save JSON, serialize game state (player/enemies/items/gates/move history), lưu local.
    \item \textbf{\texttt{screen/*}}: các màn UI (button/menu/login). Mục tiêu: gọi hàm gameplay chứ không nhét gameplay vào UI.
    \item \textbf{\texttt{skin\_module/*}}: hệ skin dạng data-driven:
    \begin{itemize}
        \item \texttt{skin\_loader.py}: đọc JSON skin, load sprite sheet, cắt frame theo \texttt{atlas\_rect/src\_rect}, build \texttt{entity.frames} và \texttt{entity.anim\_sequences}.
        \item \texttt{skin\_screen.py}: UI chọn skin, preview, apply skin.
    \end{itemize}
\end{itemize}
\subsection{Điều phối lượt chơi trong \texttt{main.py}}
Một lượt chơi trong \texttt{main.py} chạy đúng tinh thần sau:
\begin{enumerate}
    \item UI nhận input (key hoặc click).
    \item Nếu \texttt{current\_turn == "player"} và tất cả actor idle: gọi \texttt{player.move()}.
    \item Sau khi player move: gọi \texttt{check\_special\_tiles()} (key/trap), rồi \texttt{losing\_check()}.
    \item Nếu chưa chết: set \texttt{gamestate.pending\_snapshot = True}, bắt đầu enemy turn (đi lần lượt).
    \item Khi enemy đi xong và tất cả idle: chốt snapshot bằng \texttt{make\_snapshot()} rồi push vào \texttt{gamestate.storedmove}.
\end{enumerate}
\begin{figure}[H]
    \centering
   
    \includegraphics[width=0.8\textwidth]{images/turn_flowchart.png}
    \caption{Luồng điều phối lượt chơi trong \texttt{main.py}}
    \label{fig:turn_flowchart}
\end{figure}
\section{Các class chính và cách tổ chức}

\subsection{\texttt{Cell}: mô hình ô lưới và tường/cổng}
Mỗi \texttt{Cell(r,c)} là một node của map. Nó lưu trạng thái 4 cạnh:
\[
\texttt{up, down, left, right}.
\]
Quy ước trong code:
\begin{itemize}
    \item \texttt{0}: không có tường (đi được).
    \item \texttt{1}: có tường (chặn).
    \item Riêng \texttt{down} có thể là \textbf{gate ngang}:
    \begin{itemize}
        \item \texttt{2}: gate đóng
        \item \texttt{3}: gate mở
    \end{itemize}
\end{itemize}
Gate ngang được đồng bộ bởi \texttt{Gamestate.gates\_h[(rh,c)]} và được sync về \texttt{Cell.down} khi toggle hoặc apply snapshot.

\subsection{\texttt{Player}: input, animation, smooth slide}
\texttt{Player} quản lý:
\begin{itemize}
    \item Grid position: \texttt{row, col}, hướng \texttt{direction}.
    \item Lock di chuyển: \texttt{is\_moving} (đang chạy animation thì không nhận input tiếp).
    \item Smooth slide: \texttt{render\_dx/render\_dy} và bộ đếm \texttt{move\_timer/move\_total}.
    \item Skin: \texttt{set\_skin(skin\_id)} gọi \texttt{skin\_module.skin\_loader.load\_skin()} để build \texttt{frames} và sequence.
\end{itemize}

\subsection{\texttt{Enemy}: AI theo mode, đi 1 hoặc 2 bước, có \texttt{uid}}
\texttt{Enemy} có thêm vài thứ quan trọng:
\begin{itemize}
    \item \texttt{uid}: định danh ổn định để encode BFS-state và để undo restore đúng con quái.
    \item \texttt{type}: \texttt{"white\_mummy"}, \texttt{"red\_mummy"}, \texttt{"red\_scorpion"}.
    \item \texttt{pending\_steps}: danh sách bước đã plan trước (phục vụ quái 2 bước/turn).
    \item \texttt{is\_dead}: phục vụ cơ chế quái giết nhau và undo restore.
\end{itemize}

Cách triển khai 2 bước/turn:
\begin{itemize}
    \item Trong \texttt{Enemy.move()}, game gọi hàm quyết định bước:
    \begin{itemize}
        \item mode thường: dùng \texttt{new\_enemy\_position()} (Manhattan greedy)
        \item impossible: dùng \texttt{impossible\_mode\_move()} (BFS đến player)
    \end{itemize}
    \item Nếu không phải scorpion thì quái lấy \texttt{steps = 2}, plan ra \texttt{pending\_steps}.
    \item \texttt{Enemy.update(dt)} sẽ chạy animation bước 1, xong thì tự gọi \texttt{\_start\_next\_step()} để chạy bước 2.
\end{itemize}

\subsection{\texttt{Gamestate}: state chung, items, undo history, solution, gate animation}
\texttt{Gamestate} là nơi gom toàn bộ biến gameplay. Các field quan trọng đúng theo code:
\begin{itemize}
    \item \textbf{Game flow}: \texttt{state}, \texttt{mode}, \texttt{chapter}, \texttt{level}, \texttt{gameover}, \texttt{result}.
    \item \textbf{Objective}: \texttt{goal\_row}, \texttt{goal\_col}.
    \item \textbf{Items}: \texttt{keys} (set), \texttt{traps} (set), \texttt{has\_key}.
    \item \textbf{Gates}: \texttt{gates\_h} (dict \{(rh,c): bool\}), \texttt{gate\_anim\_state}.
    \item \textbf{Undo/Restart}: \texttt{storedmove} (list snapshot), \texttt{initpos} (snapshot gốc), \texttt{pending\_snapshot}.
    \item \textbf{BFS solution}: \texttt{solution} (list các hướng "up/down/left/right").
    \item \textbf{Difficulty}: \texttt{enemy\_count}, \texttt{impossible\_mode}.
\end{itemize}

\section{Undo và Restart}
\subsection{Tư tưởng triển khai}
Undo/Restart trong game không cố \textbf{tua ngược animation}. Thay vào đó, game coi mỗi lượt là một \textbf{transaction}:
\[
\text{Player action} \rightarrow \text{Enemy actions} \rightarrow \text{Commit snapshot}.
\]
Undo chỉ việc lấy snapshot trước và \texttt{apply\_snapshot()}, đảm bảo \textbf{đúng tuyệt đối}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/undo_flowchart.png}
    \caption{Quy trình Undo/Restart trong game}
    \label{fig:hinh_minh_hoa}
\end{figure}
\subsection{\texttt{make\_snapshot()}: snapshot gồm những gì}
Trong \texttt{module/module.py}, snapshot được build theo tuple, bám sát code:
\begin{itemize}
    \item Player: \texttt{(player.row, player.col, player.direction, player.skin)}.
    \item Enemies: list các tuple:
    \[
    (\texttt{uid}, \texttt{row}, \texttt{col}, \texttt{type}, \texttt{direction}, \texttt{pending\_steps}, \texttt{is\_dead}).
    \]
    \item Items:
    \begin{itemize}
        \item \texttt{keys\_state = set(gamestate.keys)}
        \item \texttt{gates\_state = dict(gamestate.gates\_h)}
    \end{itemize}
    \item Enemy kill log của lượt đó: \texttt{killed\_state} (để undo khôi phục lại quái đã bị giết).
\end{itemize}

Chi tiết quan trọng:
\begin{itemize}
    \item \texttt{killed\_uids} được dùng để \textbf{không snapshot các con đã chết} theo đúng thời điểm.
    \item Snapshot được chốt \textbf{sau khi enemy đi xong}, nên storedmove phản ánh đúng \textbf{end-of-turn state}.
\end{itemize}

\subsection{\texttt{apply\_snapshot()}: restore state và reset các cờ movement}
\texttt{apply\_snapshot()} làm các việc:
\begin{enumerate}
    \item Restore player pos/hướng/skin, reset \texttt{is\_moving}, reset slide offset.
    \item Rebuild list enemy từ \texttt{enemies\_state} (tạo lại object \texttt{Enemy()}, \texttt{set\_type()}, gán \texttt{uid}, \texttt{pending\_steps}, \texttt{is\_dead}).
    \item Restore items: \texttt{gamestate.keys}, \texttt{gamestate.gates\_h}.
    \item Sync gate state về grid:
    \[
    \texttt{Cell.down = 3 (open) hoặc 2 (closed).}
    \]
    \item Reset các cờ liên quan animation gate: rebuild \texttt{gamestate.gate\_anim\_state}.
\end{enumerate}

\subsection{Undo trong runtime (liên hệ với \texttt{main.py})}
Trong \texttt{main.py}, undo chỉ được cho phép khi \textbf{tất cả actor idle} để tránh restore giữa animation.
Sau khi undo:
\begin{itemize}
    \item clear \texttt{killed\_uids} và \texttt{killed\_this\_turn} để tránh lọc nhầm enemy vừa được restore.
\end{itemize}

\subsection{Restart}
Restart quay về snapshot gốc:
\begin{itemize}
    \item Snapshot gốc được lưu trong \texttt{gamestate.initpos} ngay sau khi load/generate level.
    \item Restart thường sẽ:
    \begin{enumerate}
        \item apply initpos,
        \item clear \texttt{storedmove} rồi push lại initpos,
        \item reset các cờ: \texttt{pending\_snapshot, gameover, result}, reset turn index trong \texttt{main.py}.
    \end{enumerate}
\end{itemize}

\section{Sinh màn chơi (Generate game)}

\subsection{Pipeline tổng trong \texttt{generate\_game()}}
\texttt{generate\_game(grid, player, enemies, gamestate)} chạy theo pipeline:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/generategame_flowchart.png}
    \caption{Quy trình sinh màn chơi trong game}
    \label{fig:hinh_minh_hoa}
\end{figure}
\begin{enumerate}
    \item \textbf{Sinh tường/đường đi} bằng \texttt{generate\_walls\_pr()} (Prim).
    \item \textbf{Random player/enemy/goal}:
    \begin{itemize}
        \item player random một ô bất kỳ,
        \item enemy random nhiều ô khác nhau (theo \texttt{gamestate.enemy\_count}),
        \item goal random trên \textbf{viền map} để tạo cảm giác “thoát ra ngoài”.
    \end{itemize}
    \item \textbf{Kiểm tra solvable} bằng \texttt{is\_playable()} (BFS state):
    \begin{itemize}
        \item nếu fail thì sinh lại (loop),
        \item nếu pass thì lưu \texttt{gamestate.solution}.
    \end{itemize}
\end{enumerate}

\subsection{Prim wall generate: \texttt{generate\_walls\_pr()}}
Hàm \texttt{generate\_walls\_pr(grid, wall\_density)} trong code làm 2 bước:

\paragraph{Bước 1: tạo maze liên thông (Prim kiểu randomized)}
\begin{itemize}
    \item Đóng tất cả tường nội bộ trước.
    \item Chọn 1 cell start ngẫu nhiên, đánh dấu visited.
    \item Duy trì danh sách frontier edges (các cạnh nối ra ngoài vùng visited).
    \item Mỗi lần chọn ngẫu nhiên 1 cạnh:
    \begin{itemize}
        \item nếu cạnh nối visited \(\leftrightarrow\) unvisited: mở tường giữa 2 cell, thêm cell mới vào visited, push frontier mới.
        \item nếu không (nối visited-visited): bỏ qua.
    \end{itemize}
\end{itemize}
Kết quả của bước này là một spanning tree trên grid, nên \textbf{chắc chắn liên thông}.

\paragraph{Bước 2: mở thêm cạnh để đạt mật độ tường mong muốn}
Trong code, game tính:
\[
\texttt{target\_walls} = \lfloor \texttt{total\_edges} \cdot \texttt{wall\_density}/100 \rfloor.
\]
Sau đó:
\begin{itemize}
    \item liệt kê toàn bộ các cạnh đang đóng,
    \item mở thêm một số cạnh ngẫu nhiên để giảm số tường về gần \texttt{target\_walls}.
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/prim_flowchart.png}
    \caption{Quy trình sinh tường bằng thuật toán Prim trong game}
    \label{fig:hinh_minh_hoa}
\end{figure}

\section{BFS path finding và kiểm tra solvable}

\subsection{BFS trong game không chỉ là BFS theo ô}
Trong \texttt{module/module.py}, solvable được kiểm bằng \texttt{is\_playable()}, thực chất gọi \texttt{path\_finding()}.
Điểm quan trọng: node của BFS là một \textbf{state}, không chỉ là \texttt{(row,col)}.

\subsection{State mà BFS đang xét (đúng theo code)}
State bao gồm:
\begin{itemize}
    \item player position: \texttt{(pr, pc)}
    \item enemy snapshot: \texttt{encode\_enemies(enemies\_state)} (sort theo uid để ổn định)
    \item keys còn lại: \texttt{keys\_state} (tuple sorted)
    \item gates state: \texttt{gates\_state} (tuple sorted \{(pos,is\_open)\})
    \item \texttt{has\_key}
\end{itemize}

\subsection{Transition trong BFS (mỗi bước tương ứng 1 lượt player)}
Từ một state, BFS thử các action:
\begin{itemize}
    \item 4 hướng di chuyển: up/down/left/right
    \item \textbf{skip} (player đứng yên) để mô phỏng input \texttt{K\_SPACE} trong runtime
\end{itemize}
Mỗi action sẽ:
\begin{enumerate}
    \item check hợp lệ theo tường/gate:
    \begin{itemize}
        \item gate đóng \texttt{Cell.down == 2} thì không qua,
        \item gate mở \texttt{Cell.down == 3} thì qua.
    \end{itemize}
    \item update key/gate:
    \begin{itemize}
        \item nếu player đứng lên key tile \((r,c)\in\texttt{keys}\): BFS giả lập \texttt{toggle\_gates} bằng cách flip toàn bộ \texttt{gates\_state}.
    \end{itemize}
    \item reject nếu player dẫm trap.
    \item giả lập enemy turn (chi tiết ở dưới).
\end{enumerate}

\subsection{Giả lập enemy turn ngay trong BFS}
Đây là phần làm cho solvable check “đúng luật game”, vì enemy cũng di chuyển theo lượt.
Trong \texttt{path\_finding()}, mỗi step BFS sẽ mô phỏng:
\begin{itemize}
    \item Mỗi enemy có thể đi 1 hoặc 2 bước:
    \[
    \texttt{steps = 2 nếu type != red\_scorpion, ngược lại 1.}
    \]
    \item Enemy chọn bước bằng:
    \begin{itemize}
        \item \texttt{enemy\_best\_step\_manhattan} nếu \texttt{impossible\_mode = False}
        \item \texttt{enemy\_best\_step\_bfs} nếu \texttt{impossible\_mode = True}
    \end{itemize}
    \item Enemy né trap: không cho bước vào trap tile.
    \item Enemy-enemy collision:
    \begin{itemize}
        \item nếu đạp lên vị trí enemy đứng yên: enemy đó bị coi là chết (đúng theo ý tưởng quái giết nhau),
        \item nếu hai enemy cùng muốn vào một ô trong cùng lượt: enemy đi sau bị block (đứng yên).
    \end{itemize}
\end{itemize}
Sau khi mô phỏng xong enemy, nếu có enemy trùng vị trí player thì state đó là \textbf{dead-end} (không enqueue).
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/bfs_flowchart.png}
    \caption{Quy trình BFS trong game}
    \label{fig:hinh_minh_hoa}
\end{figure}
\subsection{Reconstruct solution}
Khi BFS gặp goal \((pr,pc) = (\texttt{goal\_row},\texttt{goal\_col})\), code reconstruct bằng parent map, và ghi \texttt{gamestate.solution} thành list hướng đi: \texttt{"up/down/left/right"}.
Solution này được dùng trong \textbf{auto-play/hint}.

\section{Hai thuật toán đường đi chính của quái}

\subsection{Manhattan greedy: \texttt{new\_enemy\_position()}}
\texttt{new\_enemy\_position(player, enemy, grid)} là chiến lược nhanh:
\begin{itemize}
    \item thử 4 hướng hợp lệ theo tường/gate,
    \item chọn hướng làm giảm khoảng cách Manhattan:
    \[
    d = |r_e-r_p| + |c_e-c_p|.
    \]
\end{itemize}
Ưu điểm: nhẹ, tạo cảm giác “đuổi theo” nhưng vẫn bị maze làm lệch đường.

\subsection{BFS (impossible mode): \texttt{impossible\_mode\_move()}}
\texttt{impossible\_mode\_move(player, enemy, grid)} chạy BFS từ enemy tới player:
\begin{itemize}
    \item node BFS là ô trên grid,
    \item xét \texttt{can\_move\_from} có tường/gate,
    \item lấy bước đầu tiên của đường đi ngắn nhất.
\end{itemize}
Nếu BFS không tìm được đường (hiếm nhưng vẫn có thể), code fallback sang Manhattan để tránh enemy đứng im.

\subsection{Kết nối với cơ chế 2 bước/turn}
Trong \texttt{Enemy.move()}:
\begin{itemize}
    \item mỗi bước tạo một phần tử trong \texttt{pending\_steps},
    \item \texttt{Enemy.update(dt)} tự chạy hết \texttt{pending\_steps} (step 1 xong thì start step 2).
\end{itemize}
Cách này giúp gameplay “turn-based” nhưng render vẫn mượt, và không phải nhét logic 2 bước vào main loop.

\section{Tổ chức level JSON và save JSON}

\subsection{Level JSON (assets/map/*)}
Level JSON đọc bởi \texttt{read\_map\_json(filepath)} với format chính:
\begin{itemize}
    \item \texttt{"size": \{"rows": R, "cols": C\}}
    \item \texttt{"tiles"}: mảng string, mỗi ký tự là 1 tile:
    \begin{itemize}
        \item \texttt{P}: player start
        \item \texttt{W/R/S}: enemy (white\_mummy / red\_mummy / red\_scorpion)
        \item \texttt{K}: key
        \item \texttt{T}: trap
        \item \texttt{E}: exit (goal)
        \item \texttt{.}: trống
    \end{itemize}
    \item \texttt{"walls\_v"}: tường dọc (mỗi row là string độ dài \texttt{cols+1}, ký tự \texttt{|} hoặc space).
    \item \texttt{"walls\_h"}: tường ngang (mỗi row là string độ dài \texttt{cols}, ký tự:
    \texttt{-} wall, \texttt{=} gate đóng, \texttt{\textasciitilde} gate mở, space).
\end{itemize}

Khi load:
\begin{enumerate}
    \item reset toàn bộ \texttt{Cell} về 0,
    \item đọc \texttt{walls\_v/walls\_h} để set \texttt{left/right/up/down},
    \item nếu gặp \texttt{=} hoặc \texttt{\textasciitilde} thì fill \texttt{gamestate.gates\_h[(r+1,c)]},
    \item đọc tiles để đặt player, tạo enemies, fill \texttt{keys/traps}, set goal.
\end{enumerate}
Cuối cùng:
\begin{itemize}
    \item set \texttt{gamestate.initpos = make\_snapshot(...)},
    \item clear và init \texttt{storedmove} với initpos,
    \item gọi \texttt{is\_playable()} để build \texttt{gamestate.solution} cho adventure.
\end{itemize}

\subsection{Save JSON (local profile, \texttt{saveload.py})}
Save được tổ chức theo cấu trúc:
\begin{itemize}
    \item \texttt{player\_info}: \texttt{username, password, is\_guest, score, skin, owned\_skins}.
    \item \texttt{classic}: block save riêng cho classic.
    \item \texttt{adventure}: block save riêng cho adventure.
\end{itemize}

Trong mỗi mode, save có thể chứa:
\begin{itemize}
    \item \texttt{game\_state}: (grid\_size, chapter/level, player/enemies, goal, items, gates...).
    \item \texttt{map\_data}: (tiles + walls\_v/walls\_h) để continue đúng map đang chơi.
    \item \texttt{move\_history}: serialize từ \texttt{gamestate.storedmove} để continue + undo sau khi load.
\end{itemize}

Điểm quan trọng đúng theo hướng nhóm cần:
\begin{itemize}
    \item Trong code, adventure cũng serialize theo cùng pipeline và vẫn trả về \texttt{map\_data} (để continue không lệch map).
\end{itemize}

\section{Sprite sheet, animation, và hệ thống skin}

\subsection{Quy ước sprite hướng và frame}
Core animation của Player/Enemy dựa trên \texttt{entity.frames}:
\[
\texttt{frames["up"], frames["right"], frames["down"], frames["left"]}.
\]
Mỗi list chứa nhiều frame, và index frame chạy theo \texttt{entity.anim\_sequences["move"]}.

\subsection{Cắt sprite sheet kiểu grid (legacy): \texttt{add\_sprite\_frames()}}
Trong \texttt{module/module.py}, \texttt{add\_sprite\_frames(sheet, CELL\_SIZE, frames)} cắt sheet theo lưới 4x5:
\begin{itemize}
    \item row0 = up
    \item row1 = right
    \item row2 = down
    \item row3 = left
\end{itemize}
Mỗi ô được scale về \texttt{CELL\_SIZE} và append vào \texttt{frames[dir]}.

\subsection{Chạy animation + slide}
Cả Player và Enemy đều dùng cùng cơ chế:
\begin{itemize}
    \item Animation frame chạy bằng \texttt{anim\_timer}, \texttt{anim\_idx}.
    \item Slide chạy bằng \texttt{render\_dx/render\_dy} tiến dần về 0 theo thời gian.
    \item \texttt{is\_moving} khóa input và khóa việc plan step mới cho tới khi slide xong.
\end{itemize}

